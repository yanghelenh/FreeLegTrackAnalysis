% preprocessBodyTraj.m
%
% Function that takes in one or more pData files (generated by
%  preprocessBigRigFlyData.m) and extracts a bodytraj data structure, which
%  contains information about the fly's body trajectory. Saves struct back
%  into same pData file
%
% INPUTS:
%   pDataPath - full path to pData directory
%
% OUTPUTS:
%   none, but saves data back into pData file
%     bodytraj
%       t - time in sec; uses cam time, not cnc time
%       tZeroed - time in sec, zeroed; uses cam time, not cnc time
%       cam - struct with info for aligning videos to body traj
%           startFr - start frame into camera data
%           endFr - end frame into camera data
%       cnc - struct with cnc x and y position (in meters) in this t
%       x - fly's x position in arena, in meters
%       y - fly's y position in arena, in meters
%       rawAngs - fly's heading in degrees, raw from output
%       unWrAng - fly's heading in degrees, not wrapped, not smoothed
%       xSmoM - fly's x position in arena, in meters, with mild smoothing
%       ySmoM - fly's y position in arena, in meters, with mild smoothing
%       unWrAngSmoM - fly's heading in degrees, unwrapped, mild smoothing
%       xSmoS - fly's x position in arena, in meters, with strong smoothing
%       ySmoS - fly's y position in arena, in meters, with strong smoothing
%       unWrAngSmoS - fly's heading in degrees, unwrapped, strong smoothing
%       wrAng - fly's heading in degrees, wrapped to 360, no smoothing
%       wrAngSmoM - fly's heading in degrees, wrapped to 360, mild smoothing
%       wrAngSmoS - fly's heading in degrees, wrapped to 360, strong
%           smoothing
%       xVelSmoM - fly's velocity in x, in m/s, mild smoothing
%       yVelSmoM - fly's velocity in y, in m/s, mild smoothing
%       angVelSmoM - angular velocity, turns to fly's right are positive, 
%           in deg/s, mild smoothing
%       xVelSmoS - fly's velocity in x, in m/s, strong smoothing
%       yVelSmoS - fly's velocity in y, in m/s, strong smoothing
%       angVelSmoS - angular velocity, turns to fly's right are positive, 
%           in deg/s, strong smoothing
%       transVelSmoM - translational velocity in any direction, in m/s,
%           mild smoothing
%       transVelSmosS - translational velocity in any direction, in m/s,
%           strong smoothing
%       fwdVelSmoM - forward velocity, in m/s, mild smoothing
%       fwdVelSmoS - forward velocity, in m/s, strong smoothing
%       latVelSmoM - lateral velocity, in m/s (fly's right is positive),
%           mild smoothing
%       latVelSmoS - lateral velocity, in m/s (fly's right is positive),
%           strong smoothing
%       distCovered - total distance covered in trial, in m
%       angCovered - total angle covered in trial, in degrees
%       duration - duration of trial, in sec
%       SIGMA_MILD - sigma for gaussian smoothing, mild condition
%       SIGMA_STRONG - sigma for gaussian smoothing, strong condition
%     visStimType - string describing visual stimulus type, if present
%
% CREATED: 4/6/23 - HHY
%
% UPDATED:
%   4/3/23 - HHY
%
function preprocessBodyTraj(pDataPath)

    % define constants
    % max number of adjacent fly not present frames to smooth over
    MAX_FLYPRESENT_FRAMES = 3;
    % smoothing of fly behavior, window for smoothdata function, 
    %  method gaussian
    SIGMA_MILD = 15; 
    SIGMA_STRONG = 50; % aggressive smoothing

    % prompt user to select pData files
    [pDataFNames, pDataDirPath] = uigetfile('*.mat', ...
        'Select pData files', pDataPath, 'MultiSelect', 'on');
    
    % if only 1 pData file selected, not cell array; make sure loop still
    %  works 
    if (iscell(pDataFNames))
        numPDataFiles = length(pDataFNames);
    else
        numPDataFiles = 1;
    end

    % loop through all pData files
    for i = 1:numPDataFiles
    
        % handle whether it's a cell array or not
        if (iscell(pDataFNames))
            pDataName = pDataFNames{i};
        else
            pDataName = pDataFNames;
        end

        % full path for this pData file
        pDataFullPath = [pDataDirPath pDataName];

        % load trialDat from this pData file
        load(pDataFullPath, 'trialDat');

        % if the fly was present at all during the trial
        if (any(trialDat.cam.flyPresent))

            % if 1 or a few frames where fly not present, smooth over by
            %  merging across bouts
            [flyPresentStartInd, ~, flyPresentEndInd, ~] = ...
                mergeAdjVecVals(find(trialDat.cam.flyPresent), ...
                MAX_FLYPRESENT_FRAMES);
            % get fly present bout duration (in frames)
            flyPresentDur = flyPresentEndInd - flyPresentStartInd;
            % assume longest bout is valid one
            [~, valBoutInd] = max(flyPresentDur);
            % convert to start and end ind
            valStartInd = flyPresentStartInd(valBoutInd);
            valEndInd = flyPresentEndInd(valBoutInd);

        % between 2018 and 2022 datasets, eliminate indicator of fly present    
        else
            valStartInd = 1;
            valEndInd = length(trialDat.cam.flyPresent);
        end

            % camera data only for when fly present
            camT = trialDat.cam.t(valStartInd:valEndInd);
            camX = trialDat.cam.x(valStartInd:valEndInd);
            camY = trialDat.cam.y(valStartInd:valEndInd);
            camAng = trialDat.cam.ang(valStartInd:valEndInd);
            
            % start and end times of trajectory
            tStart = max([camT(1), trialDat.cnc.t(1)]);
            tEnd = min([camT(end), trialDat.cnc.t(end)]);

            % using start and end times, get start and end cam frames
            startCamFr = find(camT >= tStart, 1, 'first');
            endCamFr = find(camT <= tEnd, 1, 'last');

            % get time vector (both zeroed and not) for this fly; using cam
            %  times, only valid times
            bodytraj.t = camT(startCamFr:endCamFr);
            bodytraj.tZeroed = bodytraj.t - bodytraj.t(1);

            % get only cam values between start and end frames
            camX = camX(startCamFr:endCamFr);
            camY = camY(startCamFr:endCamFr);
            camAng = camAng(startCamFr:endCamFr);

            % add start and end cam frames to bodytraj struct
            bodytraj.cam.startFr = startCamFr;
            bodytraj.cam.endFr = endCamFr;
            
            % fly's x, y position is sum of camera and and cnc position
            % interpolate cnc position to same time points as camera
            bodytraj.cnc.x = interp1(trialDat.cnc.t, trialDat.cnc.x, ...
                bodytraj.t);
            bodytraj.x = camX + bodytraj.cnc.x;
            bodytraj.cnc.y = interp1(trialDat.cnc.t, trialDat.cnc.y, ...
                bodytraj.t);
            bodytraj.y = camY + bodytraj.cnc.y;
                
            % angles only from camera
            bodytraj.rawAngs = camAng;
            
            % unwrap angles        
            jumpThresh = 150;
            unWrAngs = [];
            angOffset = 0;
    
            for j = 1:length(bodytraj.rawAngs)
                curAng = bodytraj.rawAngs(j);
                if (j == 1)
                    unWrAngs = [unWrAngs; curAng];
                    continue;
                end
    
                curAng = curAng + angOffset;
    
                if ((unWrAngs(end) - curAng) > jumpThresh)
                    angOffset = angOffset + 180;
                    curAng = curAng + 180;
                elseif ((curAng - unWrAngs(end)) > jumpThresh)
                    angOffset = angOffset - 180;
                    curAng = curAng - 180;
                end
    
                unWrAngs = [unWrAngs; curAng];
            end
            
            % correct angles from ellipse fitting definition, camera flip
            unWrAngs = 90 - unWrAngs;
            unWrAngs = -1 * unWrAngs;
            
            bodytraj.unWrAng = unWrAngs;
    
            
            % smoothing on position
            if (SIGMA_MILD ~= 0)
                % mild smoothing
                bodytraj.xSmoM = smoothdata(bodytraj.x, 'gaussian', ...
                    SIGMA_MILD);
                bodytraj.ySmoM = smoothdata(bodytraj.y, 'gaussian', ...
                    SIGMA_MILD);
                bodytraj.unWrAngSmoM = smoothdata(bodytraj.unWrAng, ...
                    'gaussian', SIGMA_MILD);
                % aggressive smothing
                bodytraj.xSmoS = smoothdata(bodytraj.x, 'gaussian', ...
                    SIGMA_STRONG);
                bodytraj.ySmoS = smoothdata(bodytraj.y, 'gaussian', ...
                    SIGMA_STRONG);
                bodytraj.unWrAngSmoS = smoothdata(bodytraj.unWrAng, ...
                    'gaussian', SIGMA_STRONG);
            end
            
            % get wrapped angles
            bodytraj.wrAng = wrapTo360(bodytraj.unWrAng); 
            bodytraj.wrAngSmoM = wrapTo360(bodytraj.unWrAngSmoM);
            bodytraj.wrAngSmoS = wrapTo360(bodytraj.unWrAngSmoS);
            
            % compute velocities, on smoothed data
            % mild smoothing
            xVelM = gradient(bodytraj.xSmoM, bodytraj.tZeroed);
            yVelM = gradient(bodytraj.ySmoM, bodytraj.tZeroed);
            % fly's angular velocity, turns to fly's own right are positive
            angVelM = gradient(bodytraj.unWrAngSmoM, bodytraj.tZeroed);

            % strong smoothing
            xVelS = gradient(bodytraj.xSmoS, bodytraj.tZeroed);
            yVelS = gradient(bodytraj.ySmoS, bodytraj.tZeroed);
            % fly's angular velocity, turns to fly's own right are positive
            angVelS = gradient(bodytraj.unWrAngSmoS, bodytraj.tZeroed);
            
            % smooth velocities
            bodytraj.xVelSmoM = smoothdata(xVelM, 'gaussian', SIGMA_MILD);
            bodytraj.yVelSmoM = smoothdata(yVelM, 'gaussian', SIGMA_MILD);
            bodytraj.angVelSmoM = smoothdata(angVelM, 'gaussian', SIGMA_MILD);

            bodytraj.xVelSmoS = smoothdata(xVelS, 'gaussian', SIGMA_STRONG);
            bodytraj.yVelSmoS = smoothdata(yVelS, 'gaussian', SIGMA_STRONG);
            bodytraj.angVelSmoS = smoothdata(angVelS, 'gaussian',...
                SIGMA_STRONG);


            % translational velocity in any direction
            bodytraj.transVelSmoM = sqrt(bodytraj.xVelSmoM.^2 + ...
                bodytraj.yVelSmoM.^2);
            bodytraj.transVelSmoS = sqrt(bodytraj.xVelSmoS.^2 + ...
                bodytraj.yVelSmoS.^2);
            
            % forward velocity, mild smoothing
            velAngM = atan2d(bodytraj.yVelSmoM, bodytraj.xVelSmoM);
            angDiffM = velAngM - bodytraj.wrAngSmoM; 
            % fly's forward velocity, forward is positive
            bodytraj.fwdVelSmoM = bodytraj.transVelSmoM .* cosd(angDiffM);

            % forward velocity, strong smoothing
            velAngS = atan2d(bodytraj.yVelSmoS, bodytraj.xVelSmoS);
            angDiffS = velAngS - bodytraj.wrAngSmoS; 
            % fly's forward velocity, forward is positive
            bodytraj.fwdVelSmoS = bodytraj.transVelSmoS .* cosd(angDiffS);
            
            % fly's lateral velocity, movement to fly's own right is positive
            % mild smoothing
            bodytraj.latVelSmoM = bodytraj.transVelSmoM .* sind(angDiffM); 
            % strong smoothing
            bodytraj.latVelSmoS = bodytraj.transVelSmoS .* sind(angDiffS);  
            
            % distance covered (only mild smoothing)
            xCovered = sum(abs(diff(bodytraj.xSmoM)));
            yCovered = sum(abs(diff(bodytraj.ySmoM)));
            bodytraj.distCovered = xCovered + yCovered;
            bodytraj.angCovered = sum(abs(diff(bodytraj.unWrAngSmoM)));
            
            % duration of trial
            bodytraj.duration = bodytraj.t(end) - bodytraj.t(1);

            % process visual stim (if present)
            if ~isempty(trialDat.stim)
                % assign fly types based on stimulus
                switch trialDat.stim.name
                    case 'ConstantBackground'
                        switch trialDat.stim.background
                            case 0
                                visStimType = 'dark';
                            case 0.5
                                visStimType = 'gray';
                            case 1
                                visStimType = 'bright';
                        end
                    case 'SineGrating'
                        switch trialDat.stim.angle
                            case 0
                                visStimType = 'vertical';
                            case 90
                                visStimType = 'horizontal';
                        end
                    case 'RandomGrid'
                        visStimType = 'checker';
                    otherwise
                        visStimType = [];
                end 
            else
                visStimType = [];
            end

            % add sigmas to bodytraj
            bodytraj.SIGMA_MILD = SIGMA_MILD;
            bodytraj.SIGMA_STRONG = SIGMA_STRONG;

            % save data
            save(pDataFullPath, 'bodytraj', 'visStimType', '-append');

            % display status update
            fprintf('Done preprocessing body trajectory for %s\n', ...
                pDataName);
    end
end